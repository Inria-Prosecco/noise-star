#############################
# This is the main Makefile #
#############################

# This tutorial assumes you have a degree of familiarity with GNU make,
# including automatic variables such as $@, $< and $^. Some mandatory reading if
# you are not fluent in GNU make:
# - https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html#Automatic-Variables
# - https://www.gnu.org/software/make/manual/html_node/Pattern-Intro.html#Pattern-Intro
# - https://www.gnu.org/software/make/manual/html_node/Pattern_002dspecific.html#Pattern_002dspecific

# I usually prefer to rule out OSX make on the basis that it doesn't have the
# shortest stem rule, which is incredibly useful.
ifeq (,$(filter %-in,$(MAKECMDGOALS)))
ifeq (3.81,$(MAKE_VERSION))
  $(error You seem to be using the OSX antiquated Make version. Hint: brew \
    install make, then invoke gmake instead of make)
endif
endif

ifeq ($(shell uname -s),Darwin)
  ifeq (,$(shell which gsed))
    $(error gsed not found; try brew install gnu-sed)
  endif
  SED := gsed
  ifeq (,$(shell which gtime))
    $(error gtime not found; try brew install gnu-time)
  endif
  TIME := gtime
else
  SED := sed
  TIME := /usr/bin/time
endif

##########################
# Pretty-printing helper #
##########################

SHELL=/bin/bash

to-obj-dir = $(addprefix obj/,$(notdir $1))

# A helper to generate pretty logs, callable as:
#   $(call run-with-log,CMD,TXT,STEM)
#
# Arguments:
#  CMD: command to execute (may contain double quotes, but not escaped)
#  TXT: readable text to print out once the command terminates
#  STEM: path stem for the logs, stdout will be in STEM.out, stderr in STEM.err, CMD in STEM.cmd
ifeq (,$(NOSHORTLOG))
run-with-log = \
  @echo "$(subst ",\",$1)" > $3.cmd; \
  $(TIME) -q -f '%E' -o $3.time sh -c "$(subst ",\",$1)" > $3.out 2> >( tee $3.err 1>&2 ); \
  ret=$$?; \
  time=$$(cat $3.time); \
  if [ $$ret -eq 0 ]; then \
    echo "$2, $$time"; \
  else \
    echo "<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>"; \
    echo -e "\033[31mFatal error while running\033[0m: $1"; \
    echo -e "\033[31mFailed after\033[0m: $$time"; \
    echo -e "\033[36mFull log is in $3.{out,err}, see excerpt below\033[0m:"; \
    tail -n 20 $3.err; \
    echo "<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>"; \
    false; \
  fi
else
run-with-log = $1
endif


# Main entry points (first one is default)
# ----------------------------------------

# TODO: libnoiseapi.a requires libkrmllib.a... We should update the generation
# of libnoiseapi.a to make it self-contained. See the comment in benchmark/Makefile
all: dist/core/libnoisecore.a dist/api/libnoiseapi.a all-api-instances

# The API instances are automatically generated by copy-pasting and modifying
# a bit the code of the IKpsk2 instance.
.PHONY: api-instances
api-instances:
	./mk_api_instances.sh

test: spec-tests

%.test: %.exe
	$<

.PHONY: clean
clean:
	rm -f -r ./obj/* ./dist/*

# We need those flags to properly extract code which uses Vale
ADDITIONAL_VALE_KRML_FLAGS = \
  -library 'Vale.Stdcalls.*' \
  -no-prefix 'Vale.Stdcalls.*' \
  -static-header 'Vale.Inline.*' \
  -library 'Vale.Inline.X64.Fadd_inline' \
  -library 'Vale.Inline.X64.Fmul_inline' \
  -library 'Vale.Inline.X64.Fswap_inline' \
  -library 'Vale.Inline.X64.Fsqr_inline' \
  -no-prefix 'Vale.Inline.X64.Fadd_inline' \
  -no-prefix 'Vale.Inline.X64.Fmul_inline' \
  -no-prefix 'Vale.Inline.X64.Fswap_inline' \
  -no-prefix 'Vale.Inline.X64.Fsqr_inline' \
  -no-prefix 'EverCrypt.Vale'

include Makefile.include

# Definition of F* flags
# ----------------------

FSTAR_HINTS ?= --use_hints --use_hint_hashes --record_hints

# This flag controls what gets extracted to OCaml. Generally, we don't extract
# the FStar namespace since it's already extracted and packaged as the ocamlfind
# package fstarlib. Here, unlike in -bundle, +Spec matches both Spec and
# Spec.*
FSTAR_EXTRACT = --extract 'OCaml:-* +Spec.Noise +Spec.Chacha20Poly1305.Test +Spec.Curve25519.Test +Spec.HMAC.Test'

# Some reasonable flags to turn on:
# - 247: checked file not written because some of its dependencies...
# - 285: missing or file not found, almost always something to act on
# - 241: stale dependencies, almost always a sign that the build is incorrect
#
# But also:
# - --cmi, for cross-module inlining, a must-have for anyone who relies on
#   inline_for_extraction in the presence of interfaces
# - --cache_checked_modules to rely on a pre-built ulib and krmllib
# - --cache_dir, to avoid polluting our generated build artifacts outside o
FSTAR_OPTIONS = $(FSTAR_HINTS) \
  --odir obj --cache_checked_modules $(FSTAR_INCLUDES) --cmi \
  --already_cached '* -Impl.Noise -Spec.Noise -Meta.Noise -Sec.Noise -Spec.Hash.KeyedHash -Spec.Chacha20Poly1305.Test -Spec.Curve25519.Test -Spec.HMAC.Test' --warn_error '+241@247+285-274' \
  --cache_dir obj --hint_dir hints
FSTAR_NO_FLAGS = $(FSTAR_HOME)/bin/fstar.exe $(FSTAR_OPTIONS)

# Initial dependency analysis
# ---------------------------

# Argument list too long :( can't use wildcard
FSTAR_ROOTS = $(NOISE_HOME)/*.fsti $(addsuffix /*.fst,$(SOURCE_DIRS))


# This is the only bulletproof way that I know of forcing a regeneration of the
# .depend file every single time. Why, you may ask? Well, it's frequent enough
# to add a new file that you don't want to decipher a cryptic error only to
# remember you should run `make depend`. Also, if you move files around, it's
# good to force regeneration even though .depend may be more recent than the
# mtime of the moved files.
ifndef NODEPEND
ifndef MAKE_RESTARTS
.depend: .FORCE
	$(call run-with-log,\
	  $(FSTAR_NO_FLAGS) --dep full $(FSTAR_ROOTS) $(FSTAR_EXTRACT) > $@\
	  ,[FSTAR-DEPEND],$(call to-obj-dir,depend))

.PHONY: .FORCE
.FORCE:
endif
endif

ifeq (,$(filter %-in,$(MAKECMDGOALS)))
-include .depend
endif

# Verification
# ------------

# Everest-specific idiom: all makefiles accept OTHERFLAGS, for instance, if one
# wants to rebuild with OTHERFLAGS="--admit_smt_queries true". We just don't
# pass such flags to the dependency analysis.
FSTAR = $(FSTAR_NO_FLAGS) $(OTHERFLAGS)

# Creating these directories via a make rule, rather than rely on F* creating
# them, as two calls to F* might race.
hints:
	mkdir $@

obj:
	mkdir $@

# We allow some specific pattern rules to be added here, relying on the shortest
# stem rule for them to take precedence. For instance, you may want to do:
#
# obj/Bignum.Impl.fst.checked: FSTAR_FLAGS = "--query_stats"
#
# (Note: for options that control the SMT encoding, such as
# --smtencoding.nl_arith_repr native, please make sure you also define them in
# Makefile.common for %.fst-in otherwise you'll observe different behaviors
# between interactive and batch modes.)
#
# By default, however, variables are inherited through the dependencies, meaning
# that the example above would normally set these FSTAR_FLAGS for any .checked
# that is rebuilt because it's a dependency of Bignum.Impl.fst.checked.
#
# To avoid this unpleasant behavior, the most general pattern rule (longest
# stem) also defines a suitable default value for FSTAR_FLAGS.
%.checked: FSTAR_FLAGS=

# Note: F* will not change the mtime of a checked file if it is
# up-to-date (checksum matches, file unchanged), but this will confuse
# make and result in endless rebuilds. So, we touch that file.
%.checked: | hints obj
	$(call run-with-log, \
	  $(FSTAR) $< $(FSTAR_FLAGS) && touch -c $@ \
	  ,[VERIFY] $(notdir $*),$(call to-obj-dir,$@))


# Extraction
# ----------

# A few mismatches here between the dependencies present in the .depend and the
# expected F* invocation. In .depend:
#
# obj/Bignum_Impl.ml: obj/Bignum.Impl.fst.checked ... more dependencies ...
#
# But F* wants (remember that F* searches for source files anywhere on the
# include path):
#
# fstar Bignum.Impl.fst --extract_module BigNum.Impl
#
# We use basename because we may also extract krml files from .fsti.checked
# files (not true for OCaml, we don't extract mlis from fstis).
.PRECIOUS: obj/%.ml
obj/%.ml:
	$(call run-with-log, \
	  $(FSTAR) $(notdir $(subst .checked,,$<)) --codegen OCaml \
	  --extract_module $(basename $(notdir $(subst .checked,,$<)))\
	  ,[EXTRACT-ML] $(notdir $*),$(call to-obj-dir,$@))

.PRECIOUS: obj/%.krml
obj/%.krml:
	$(call run-with-log, \
	  $(FSTAR) $(notdir $(subst .checked,,$<)) --codegen krml \
	  --extract_module $(basename $(notdir $(subst .checked,,$<)))\
	  ,[EXTRACT-KRML] $(notdir $*),$(call to-obj-dir,$@))

%.fsti-in %.fst-in:
	@echo $(FSTAR_OPTIONS)

obj/Spec_Noise_Testing_Load.ml: ml/Spec_Noise_Testing_Load.ml
	# This ensures that all the source directories are not polluted with
	# build artifacts
	cp $< $@

# F* --> C
# --------

KRML=$(KRML_HOME)/krml

# Note: the implementation of the intrinsic uses external linkage, but you could
# easily turn this file into a .h, use -add-include '"Impl_Bignum_Intrinsics.h"'
# and pass -static-header Impl.Bignum.Intrinsics as described in the
# documentation.
HAND_WRITTEN_C_FILES =

# This is now the preferred and recommended way to compile C code with KaRaMeL.
#
# KaRaMeL (via -skip-compilation) only generates a stub Makefile in dist/,
# instead of acting as a C compilation driver like it did before. The Makefile
# that is generated by KaRaMeL is basic, but takes into account:
# - the -o option to determine what is being built
# - the C files passed on the command line, which will be linked together
# - C compiler flags passed to KaRaMeL via -ccopts
#
# This Makefile is called Makefile.basic and should be enough for all your basic
# needs. If you need something more fancy, you can easily author your own custom
# dist/Makefile, which includes Makefile.basic, then proceeds to redefine /
# tweak some variables.
#
# Note that you are of course more than welcome to define your own
# CMakeLists.txt or whatever your favorite build system is: this tutorial only
# describes the supported canonical way of compiling code.
#
# See the advanced topics section for an in-depth explanation of how the -bundle
# option works. We also use -minimal.
NOISE_CORE_BUNDLE = -bundle 'Impl.Noise.Instances='[rename=Noise]

# The API bundle puts together some of the instances, for testing purposes
NOISE_API_BUNDLE = \
	-bundle Impl.Noise.API.Session+Impl.Noise.API.Instances.IKpsk2_25519_ChaChaPoly_BLAKE2s+Impl.Noise.API.Instances.IK_25519_ChaChaPoly_BLAKE2s+Impl.Noise.API.Instances.IX_25519_ChaChaPoly_BLAKE2s+Impl.Noise.API.Instances.XX_25519_ChaChaPoly_BLAKE2s+Impl.Noise.API.Instances.NN_25519_ChaChaPoly_BLAKE2s+Impl.Noise.API.Instances.NNpsk0_25519_ChaChaPoly_BLAKE2s+Impl.Noise.API.Instances.NX_25519_ChaChaPoly_BLAKE2s+Impl.Noise.API.Instances.X_25519_ChaChaPoly_BLAKE2s=[rename=NoiseAPI]

# If we add rename-prefix in the below bundle, all the definitions are renamed.
# It is probably because the Impl.Noise.* pattern is too general.
NOISE_API_OTHER_BUNDLE = \
	-bundle 'Impl.Noise.API.Instances.Common=Impl.Noise.*'[rename=Noise]

KRML_FLAGS += -header c/header.h

# The protocol instanciations, in one subdirectory
dist/core/Makefile.basic: $(filter-out %prims.krml,$(ALL_KRML_FILES)) $(HAND_WRITTEN_C_FILES)
	mkdir -p $(dir $@)
	[ x"$(HAND_WRITTEN_C_FILES)" != x ] && cp $(HAND_WRITTEN_C_FILES) $(dir $@) || true
	$(KRML) -tmpdir $(dir $@) -skip-compilation \
	  $(filter %.krml,$^) \
	  -warn-error @4@5@18 \
	  -fparentheses \
	  -fnoanonymous-unions \
	  $(NOISE_CORE_BUNDLE) \
	  -bundle '*[rename=Hacl]'\
	  -library Hacl.* \
	  -minimal \
	  -add-include '<stdint.h>' \
	  -add-include '"krml/internal/target.h"' \
	  -add-include '"krml/internal/types.h"' \
	  -o libnoisecore.a \
	  $(KRML_FLAGS)

# This file is generated by mk_api_instances.sh. It contains the rules to
# compile all the specialized API instances.
include Makefile.instances

# The general rule to generate the C files for a specific instance of the API
# Parameterized by the following variables:
# PATTERN_NAME: "IKpsk2", "NN", etc.
# CIPHERSUITE_NAME: "25519_AESGCM_SHA512", etc.
# Those variables should have been properly defined in Makefile.instances for
# all the instanciations of the rule.
dist/api-%/Makefile.basic: $(filter-out %prims.krml,$(ALL_KRML_FILES)) $(HAND_WRITTEN_C_FILES)
	mkdir -p $(dir $@)
	[ x'$(HAND_WRITTEN_C_FILES)' != x ] && cp $(HAND_WRITTEN_C_FILES) $(dir $@) || true
	$(KRML) -tmpdir $(dir $@) -skip-compilation \
	  $(filter %.krml,$^) \
	  -warn-error @4@5@18 \
	  -fparentheses \
	  -fnoanonymous-unions \
          $(VALE_BUNDLES) \
          $(ADDITIONAL_VALE_KRML_FLAGS) \
          -bundle 'EverCrypt,EverCrypt.\*[rename=EverCrypt]' \
          -library EverCrypt,EverCrypt.* \
          -bundle 'FStar.\*,LowStar.\*,C,C.\*[rename=Mitls_Kremlib]' \
	  -bundle Impl.Noise.API.Session+Impl.Noise.API.Instances.$(PATTERN_NAME)_$(CIPHERSUITE_NAME)=[rename=$(PATTERN_NAME),rename-prefix] \
	  -bundle 'Impl.Noise.API.Instances.Common_$(CIPHERSUITE_NAME)=Impl.Noise.*'[rename=Noise_$(PATTERN_NAME),rename-prefix] \
	  -bundle '*[rename=Hacl]'\
	  -library Hacl.* \
	  -minimal \
	  -add-include '<stdint.h>' \
	  -add-include '"krml/internal/target.h"' \
	  -add-include '"krml/internal/types.h"' \
	  -o libnoiseapi.a \
	  $(KRML_FLAGS)

# Compiling the generated C code
# ------------------------------

# Here we do a recursive make invocation because a new dependency analysis needs
# to be performed on the generated C files. This recursive make deals with all
# the files copied in dist, which includes karamel-generated and hand-written,
# copied files from HAND_WRITTEN_C_FILES.

dist/core/libnoisecore.a: dist/core/Makefile.basic
	$(MAKE) -C $(dir $@) -f $(notdir $<)

dist/api/libnoiseapi.a: dist/api/Makefile.basic
	$(MAKE) -C $(dir $@) -f $(notdir $<)

dist/api-%/libnoiseapi.a: dist/api-%/Makefile.basic
	$(MAKE) -C $(dir $@) -f $(notdir $<)

# Compiling the generated OCaml code
# ----------------------------------

# This is much more difficult, and you're probably better off calling OCamlbuild
# or Dune at this stage. Nonetheless, I still show how to compile the generate
# OCaml code with only GNU make and without relying on an external tool or an
# extra dependency analysis.

# First complication... no comment.
ifeq ($(OS),Windows_NT)
  export OCAMLPATH := $(FSTAR_HOME)/bin;$(OCAMLPATH)
else
  export OCAMLPATH := $(FSTAR_HOME)/bin:$(OCAMLPATH)
endif

# Second complication: F* generates a list of ML files in the reverse linking
# order. No POSIX-portable way of reversing the order of a list.
TAC = $(shell which tac >/dev/null 2>&1 && echo "tac" || echo "tail -r")

ALL_CMX_FILES = $(patsubst %.ml,%.cmx,$(shell echo $(ALL_ML_FILES) | $(TAC)))

# Third complication: F* does not know about our hand-written files. So, we need
# to manually add dependency edges in the graph. In our case, the test driver
# needs all files to be built before. This is convenient because the
# hand-written file only needs to be inserted at the end of the list of CMX
# files. If it had to be inserted somewhere in the middle of the topological
# order, it would be trickier...

obj/Spec_Noise_Patterns_Test.cmx: obj/Spec_Noise_Testing_Load.cmx

# Finally, how to compile things...

OCAMLOPT = ocamlfind opt -package fstarlib -linkpkg -g -I $(HACL_HOME)/obj -I $(NOISE_HOME)/obj -w -8-20-26

.PRECIOUS: obj/%.cmx
obj/%.cmx: obj/%.ml
	$(OCAMLOPT) -c $< -o $@

.PRECIOUS: dist/test/ml/%_AutoTest.ml
dist/test/ml/%_AutoTest.ml:
	mkdir -p $(dir $@)
	echo "if not ($*.test ()) then (print_endline \"$* failed\"; exit 1)" > $@

dist/test/ml/%.exe: $(subst obj/Spec_Noise_Patterns_Test.cmx,obj/Spec_Noise_Testing_Load.cmx obj/Spec_Noise_Patterns_Test.cmx,$(ALL_CMX_FILES)) dist/test/ml/%_AutoTest.ml
	$(OCAMLOPT) $(HACL_HOME)/obj/libhaclml.cmxa $^ -o $@

spec-tests: $(patsubst %_fst,dist/test/ml/%.test,$(subst .,_,$(notdir $(wildcard tests/*.fst))))

# Compiling the hand-written test
# -------------------------------

CFLAGS += -I dist -I $(KRML_HOME)/include

tests/c-tests.exe: dist/libnoise.a tests/c-tests.o
	$(CC) $^ -o $@
